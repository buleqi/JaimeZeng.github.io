{"title":"Git 工作流","uid":"4ed00788422e64ad67195cd4951f38dd","slug":"2020-09-05-Git-工作流","date":"2020-09-18T10:35:43.000Z","updated":"2021-09-22T18:02:07.833Z","comments":true,"path":"api/articles/2020-09-05-Git-工作流.json","keywords":null,"cover":[],"content":"<h2 id=\"Git-工作流\"><a href=\"#Git-工作流\" class=\"headerlink\" title=\"Git 工作流\"></a>Git 工作流</h2><p>提到版本控制管理系统，很多人会第一时间才能想到 SVN 和 Git。而 SVN 和 Git 除了集中式和分布式的区别外，就是分支管理。相比 SVN，Git 提供更丰富的分支特性。</p>\n<p>Git 工作流如下图所示：</p>\n<p><img src=\"https://img.zxj.guru/2020/09/git-flow.png\" alt=\"git-flow\"></p>\n<p>现在让我们来看一个最简单的分支管理的例子。</p>\n<ol>\n<li><p>开发某个网站，为实现某个新的需求，创建一个分支并在这个分支上开展工作。</p>\n</li>\n<li><p>此时，你突然接到一个电话说有个 <code>Bug</code> 需要紧急修补。</p>\n</li>\n<li><p>返回到原先已经发布到生产服务器上的分支，为这次紧急修补建立一个新分支，并在其中修复问题。</p>\n</li>\n<li><p>通过测试后，回到生产服务器所在的分支，将修补分支合并进来，然后再推送到生产服务器上。</p>\n</li>\n<li><p>切换到之前实现新需求的分支，将修补分支合并进来，然后继续工作。</p>\n</li>\n</ol>\n<p>这里我们参考 <a href=\"https://nvie.com/posts/a-successful-git-branching-model/\">A successful Git branching model</a> 一文来学习 Git 的分支管理。</p>\n<h2 id=\"主分支\"><a href=\"#主分支\" class=\"headerlink\" title=\"主分支\"></a>主分支</h2><p>主分支包括 <code>master</code> 分支和 <code>develop</code> 分支。</p>\n<ul>\n<li><code>master</code> 分支</li>\n<li><code>develop</code> 分支</li>\n</ul>\n<p><code>master</code> 分支用来发布，<code>HEAD</code> 就是当前线上的运行代码。<code>develop</code> 分支就是我们的日常开发。使用这两个分支就具有了最简单的开发模式：<code>develop</code> 分支用来开发功能，开发完成并且测试没有问题则将 <code>develop</code> 分支的代码合并到 <code>master</code> 分支并发布。</p>\n<p><img src=\"https://img.zxj.guru/2020/09/main-branches.png\" alt=\"main-branches\"></p>\n<h2 id=\"辅助分支\"><a href=\"#辅助分支\" class=\"headerlink\" title=\"辅助分支\"></a>辅助分支</h2><p>主要介绍的辅助分支如下：</p>\n<ul>\n<li><code>feature</code> 分支</li>\n<li><code>release</code> 分支</li>\n<li><code>hotfix</code> 分支</li>\n</ul>\n<p>通过这些分支，我们可以做到：团队成员之间并行开发，<code>feature track</code> 更加容易，开发和发布并行以及线上问题修复。辅助分支与主分支的不同点：辅助分支是有限的生命期，他们最终会被移除。</p>\n<h3 id=\"Feature-分支\"><a href=\"#Feature-分支\" class=\"headerlink\" title=\"Feature 分支\"></a>Feature 分支</h3><p><code>feature</code> 分支用来开发具体的功能，一般 fork 自 <code>develop</code> 分支，最终可能会合并到 <code>develop</code> 分支。比如我们要在下一个版本增加功能 1、功能 2、功能 3。那么我们就可以起三个 <code>feature</code> 分支：<code>feature1</code> 、 <code>feature2</code> 和 <code>feature3</code>。（<code>feature</code> 分支命名最好能够自解释，这并不是一种好的命名。）随着我们开发，功能 1 和功能 2 都被完成了，而功能 3 因为某些原因完成不了，那么最终 <code>feature1</code> 和 <code>feature2</code> 分支将被合并到 <code>develop</code> 分支，而 <code>feature3</code> 分支将被干掉。</p>\n<p><img src=\"https://img.zxj.guru/2020/09/feature-branches.png\" alt=\"feature-branches\"></p>\n<h4 id=\"建立-feature-分支并切换到-feature-分支\"><a href=\"#建立-feature-分支并切换到-feature-分支\" class=\"headerlink\" title=\"建立 feature 分支并切换到 feature 分支\"></a>建立 feature 分支并切换到 feature 分支</h4><p>从 develop 分支建立 feature 分支并切换到 feature 分支。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ git checkout -b myfeature develop\nSwitched to a new branch &quot;myfeature&quot;</code></pre>\n\n<h4 id=\"合并-feature-分支到-develop\"><a href=\"#合并-feature-分支到-develop\" class=\"headerlink\" title=\"合并 feature 分支到 develop\"></a>合并 feature 分支到 develop</h4><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ git checkout develop\nSwitched to branch &#39;develop&#39;\n$ git merge --no-ff myfeature\nUpdating ea1b82a..05e9557\n(Summary of changes)\n$ git branch -d myfeature\nDeleted branch myfeature\n$ git push origin develop</code></pre>\n\n<p>上面我们 merge 分支的时候使用了参数 <code>--no-ff</code>，ff 是<code>fast-forward</code> 的意思，<code>--no-ff</code>就是禁用<code>fast-forward</code>。关于这两种模式的区别如下图。（可以使用 <code>sourceTree</code> 或者命令<code>git log --graph</code>查看。）</p>\n<p><img src=\"https://img.zxj.guru/2020/09/merge-without-ff.png\" alt=\"merge-without-ff\"></p>\n<p>看了上面的图，那么使用非<code>fast-forward</code>模式来 <code>merge</code> 的好处就不言而喻了：我们知道哪些 <code>commit</code> 是某些 <code>feature</code> 相关的。虽然 <code>git merge</code> 的时候会自动判断是否使用<code>fast-farward</code>模式，但是有时候为了更明确，我们还是要加参数<code>--no-ff</code>或者<code>--ff</code>。</p>\n<h3 id=\"Release-分支\"><a href=\"#Release-分支\" class=\"headerlink\" title=\"Release 分支\"></a>Release 分支</h3><p><code>release</code> 分支在我看来是 <code>pre-master</code>。<code>release</code> 分支从 <code>develop</code> 分支 <code>fork</code> 出来，最终会合并到 <code>develop</code> 分支和 <code>master</code> 分支。合并到 <code>master</code> 分支上就是可以发布的代码了。有人可能会问那为什么合并回 <code>develop</code> 分支呢？很简单，有了 <code>release</code> 分支，那么相关的代码修复就只会在 <code>release</code> 分支上改动了，最后必然要合并到 <code>develop</code> 分支。下面细说。</p>\n<p>我们最初所有的开发工作都在 <code>develop</code> 分支上，当我们这一期的功能开发完毕的时候，我们基于 <code>develop</code> 分支开一个新的 <code>release</code> 分支。这个时候我们就可以对 <code>release</code> 分支做统一的测试了，另外做一些发布准备工作：比如版本号之类的。</p>\n<p>如果测试工作或者发布准备工作和具体的开发工作由不同人来做，比如国内的 <code>RD</code> 和 <code>QA</code>，这个 <code>RD</code> 就可以继续基于 <code>develop</code> 分支继续开发了。再或者说公司对于发布有严格的时间控制，开发工作提前并且完美的完成了，这个时候我们就可以在 <code>develop</code> 分支上继续我们下一期的开发了。同时如果测试有问题的话，我们将直接在 <code>release</code> 分支上修改，然后将修改合并到 <code>develop</code> 分支上。</p>\n<p>待所有的测试和准备工作做完之后，我们就可以将 <code>release</code> 分支合并到 <code>master</code> 分支上，并进行发布了。</p>\n<p>一些相关命令如下。</p>\n<h4 id=\"新建-release-分支\"><a href=\"#新建-release-分支\" class=\"headerlink\" title=\"新建 release 分支\"></a>新建 release 分支</h4><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ git checkout -b release-1.2 develop\nSwitched to a new branch &quot;release-1.2&quot;\n$ .&#x2F;bump-version.sh 1.2\nFile modified successfully, version bumped to 1.2.\n$ git commit -a -m &quot;Bumped version number to 1.2&quot;\n[release-1.2 74d9424] Bumped version number to 1.2\n1 files changed, 1 insertions(+), 1 deletions(-)</code></pre>\n\n<h4 id=\"release-分支合并到-master-分支\"><a href=\"#release-分支合并到-master-分支\" class=\"headerlink\" title=\"release 分支合并到 master 分支\"></a>release 分支合并到 master 分支</h4><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ git checkout master\nSwitched to branch &#39;master&#39;\n$ git merge --no-ff release-1.2\nMerge made by recursive.\n(Summary of changes)\n$ git tag -a 1.2</code></pre>\n\n<h4 id=\"release-分支合并到-develop-分支\"><a href=\"#release-分支合并到-develop-分支\" class=\"headerlink\" title=\"release 分支合并到 develop 分支\"></a>release 分支合并到 develop 分支</h4><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ git checkout develop\nSwitched to branch &#39;develop&#39;\n$ git merge --no-ff release-1.2\nMerge made by recursive.\n(Summary of changes)</code></pre>\n\n<h4 id=\"删除-release-分支\"><a href=\"#删除-release-分支\" class=\"headerlink\" title=\"删除 release 分支\"></a>删除 release 分支</h4><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ git branch -d release-1.2\nDeleted branch release-1.2 (was ff452fe).</code></pre>\n\n<h3 id=\"Hotfix-分支\"><a href=\"#Hotfix-分支\" class=\"headerlink\" title=\"Hotfix 分支\"></a>Hotfix 分支</h3><p>顾名思义，<code>hotfix</code> 分支用来修复线上 <code>bug</code>。当线上代码出现 <code>bug</code> 时，我们基于 <code>master</code> 分支开一个 <code>hotfix</code> 分支，修复 bug 之后再将 <code>hotfix</code> 分支合并到 <code>master</code> 分支并进行发布，同时 <code>develop</code> 分支作为最新最全的代码分支，<code>hotfix</code> 分支也需要合并到 <code>develop</code> 分支上去。仔细想一想，其实 <code>hotfix</code> 分支和 <code>release</code> 分支功能类似。<code>hotfix</code> 的好处是不打断 <code>develop</code> 分支正常进行，同时对于现实代码的修复貌似也没有更好的方法了.</p>\n<p><img src=\"https://img.zxj.guru/2020/09/hotfix-branches.png\" alt=\"hotfix-branches\"></p>\n<p>一些相关的命令。</p>\n<h4 id=\"新建-hotfix-分支\"><a href=\"#新建-hotfix-分支\" class=\"headerlink\" title=\"新建 hotfix 分支\"></a>新建 hotfix 分支</h4><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ git checkout -b hotfix-1.2.1 master\nSwitched to a new branch &quot;hotfix-1.2.1&quot;\n$ .&#x2F;bump-version.sh 1.2.1\nFiles modified successfully, version bumped to 1.2.1.\n$ git commit -a -m &quot;Bumped version number to 1.2.1&quot;\n[hotfix-1.2.1 41e61bb] Bumped version number to 1.2.1\n1 files changed, 1 insertions(+), 1 deletions(-)</code></pre>\n\n<h4 id=\"Fix-bug\"><a href=\"#Fix-bug\" class=\"headerlink\" title=\"Fix bug\"></a>Fix bug</h4><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ git commit -m &quot;Fixed severe production problem&quot;\n[hotfix-1.2.1 abbe5d6] Fixed severe production problem\n5 files changed, 32 insertions(+), 17 deletions(-)</code></pre>\n\n<h4 id=\"hotfix-合并到-master\"><a href=\"#hotfix-合并到-master\" class=\"headerlink\" title=\"hotfix 合并到 master\"></a>hotfix 合并到 master</h4><p>Fix bug 之后，<code>hotfix</code> 合并到 <code>master</code></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ git checkout master\nSwitched to branch &#39;master&#39;\n$ git merge --no-ff hotfix-1.2.1\nMerge made by recursive.\n(Summary of changes)\n$ git tag -a 1.2.1</code></pre>\n\n<h4 id=\"hotfix-合并到-develop-分支\"><a href=\"#hotfix-合并到-develop-分支\" class=\"headerlink\" title=\"hotfix 合并到 develop 分支\"></a>hotfix 合并到 develop 分支</h4><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ git checkout develop\nSwitched to branch &#39;develop&#39;\n$ git merge --no-ff hotfix-1.2.1\nMerge made by recursive.\n(Summary of changes)</code></pre>\n\n<h4 id=\"删除-hotfix-分支\"><a href=\"#删除-hotfix-分支\" class=\"headerlink\" title=\"删除 hotfix 分支\"></a>删除 hotfix 分支</h4><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ git branch -d hotfix-1.2.1\nDeleted branch hotfix-1.2.1 (was abbe5d6).</code></pre>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li><code>master</code> 分支：主分支，主要存放已经发布到生产服务器上的代码。</li>\n<li><code>develop</code> 分支：日常开发分支，该分支从 <code>master</code> 分支拉取，主要存放着在实现新的产品需求时开发的代码。</li>\n<li><code>feature</code> 分支：日常开发特性分支。一般从 <code>develop</code> 分支拉取，主要存放着在实现新产品需求具体功能时开发的代码。具体功能开发完成之后将合并到 <code>develop</code> 分支。</li>\n<li><code>release</code> 分支：产品发布测试分支。主要存放着从 <code>develop</code> 分支合并过来的代码。 <code>develop</code> 分支的代码在新的产品需求全部实现后会合并到 <code>release</code> 分支进行测试，测试没有问题后（到了发布日期）将会合并到 <code>master</code> 分支并发布。测试有问题将会在 <code>release</code> 分支修改，修改测试没问题后将会合并到 <code>master</code> 分支和 <code>develop</code> 分支。</li>\n<li><code>hotfix</code> 分支：线上 bug 修复分支。主要存放这在紧急修补中为修复问题开发的代码，在测试没有问题后将会合并到 <code>master</code> 分支和 <code>develop</code> 分支。</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://nvie.com/posts/a-successful-git-branching-model/\">A successful Git branching model » nvie.com</a></li>\n<li><a href=\"http://legendtkl.com/2016/12/31/git-good-practice-gitflow/\">git 最佳实践: 分支管理 | Legendtkl</a></li>\n</ul>\n","text":"Git 工作流提到版本控制管理系统，很多人会第一时间才能想到 SVN 和 Git。而 SVN 和 Git 除了集中式和分布式的区别外，就是分支管理。相比 SVN，Git 提供更丰富的分支特性。 Git 工作流如下图所示： 现在让我们来看一个最简单的分支管理的例子。 开发某个网站，...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"Git","slug":"Git","count":1,"path":"api/categories/Git.json"}],"tags":[{"name":"Git","slug":"Git","count":1,"path":"api/tags/Git.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Git-%E5%B7%A5%E4%BD%9C%E6%B5%81\"><span class=\"toc-text\">Git 工作流</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E5%88%86%E6%94%AF\"><span class=\"toc-text\">主分支</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BE%85%E5%8A%A9%E5%88%86%E6%94%AF\"><span class=\"toc-text\">辅助分支</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Feature-%E5%88%86%E6%94%AF\"><span class=\"toc-text\">Feature 分支</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BB%BA%E7%AB%8B-feature-%E5%88%86%E6%94%AF%E5%B9%B6%E5%88%87%E6%8D%A2%E5%88%B0-feature-%E5%88%86%E6%94%AF\"><span class=\"toc-text\">建立 feature 分支并切换到 feature 分支</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%90%88%E5%B9%B6-feature-%E5%88%86%E6%94%AF%E5%88%B0-develop\"><span class=\"toc-text\">合并 feature 分支到 develop</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Release-%E5%88%86%E6%94%AF\"><span class=\"toc-text\">Release 分支</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B0%E5%BB%BA-release-%E5%88%86%E6%94%AF\"><span class=\"toc-text\">新建 release 分支</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#release-%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E5%88%B0-master-%E5%88%86%E6%94%AF\"><span class=\"toc-text\">release 分支合并到 master 分支</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#release-%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E5%88%B0-develop-%E5%88%86%E6%94%AF\"><span class=\"toc-text\">release 分支合并到 develop 分支</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%A0%E9%99%A4-release-%E5%88%86%E6%94%AF\"><span class=\"toc-text\">删除 release 分支</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Hotfix-%E5%88%86%E6%94%AF\"><span class=\"toc-text\">Hotfix 分支</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B0%E5%BB%BA-hotfix-%E5%88%86%E6%94%AF\"><span class=\"toc-text\">新建 hotfix 分支</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Fix-bug\"><span class=\"toc-text\">Fix bug</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#hotfix-%E5%90%88%E5%B9%B6%E5%88%B0-master\"><span class=\"toc-text\">hotfix 合并到 master</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#hotfix-%E5%90%88%E5%B9%B6%E5%88%B0-develop-%E5%88%86%E6%94%AF\"><span class=\"toc-text\">hotfix 合并到 develop 分支</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%A0%E9%99%A4-hotfix-%E5%88%86%E6%94%AF\"><span class=\"toc-text\">删除 hotfix 分支</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol>","author":{"name":"JaimeZeng","slug":"blog-author","avatar":"https://cdn.staticaly.com/gh/JaimeZeng/cdn/main/blog/avatar.png","link":"/","description":"Stay Simple.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":"https://github.com/JaimeZeng"}}},"mapped":true,"prev_post":{"title":"变量的高级用法","uid":"a6f9db63870b876ac4f0e8fb7a8c3c63","slug":"2020-10-03-02_变量的高级用法","date":"2020-10-03T11:20:26.000Z","updated":"2021-09-22T18:02:07.833Z","comments":true,"path":"api/articles/2020-10-03-02_变量的高级用法.json","keywords":null,"cover":null,"text":"该小节介绍了变量的高级用法，如何进行变量替换、字符串处理方法、如何利用命令替换为变量赋值、有类型变量和变量引用的使用方法，并在实际环境中演示如何使用，加深大家的认识和理解；最后介绍 shell 中的数学运算方法，使用 expr 和 bc… 变量替换和测试变量替换 语法 说明 $&...","link":"","photos":[],"count_time":{"symbolsCount":"24k","symbolsTime":"22 mins."},"categories":[{"name":"Linux","slug":"Linux","count":10,"path":"api/categories/Linux.json"}],"tags":[{"name":"Linux","slug":"Linux","count":8,"path":"api/tags/Linux.json"},{"name":"Shell","slug":"Shell","count":5,"path":"api/tags/Shell.json"}],"author":{"name":"JaimeZeng","slug":"blog-author","avatar":"https://cdn.staticaly.com/gh/JaimeZeng/cdn/main/blog/avatar.png","link":"/","description":"Stay Simple.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":"https://github.com/JaimeZeng"}}}},"next_post":{"title":"CentOS 7 升级 gcc","uid":"92309251cf261dbf3ee26b874b03ce39","slug":"2020-08-01-CentOS-7-升级-gcc","date":"2020-08-01T12:33:16.000Z","updated":"2021-09-22T18:02:07.833Z","comments":true,"path":"api/articles/2020-08-01-CentOS-7-升级-gcc.json","keywords":null,"cover":null,"text":"Centos7 gcc 版本默认 4.8.5，而有些软件（例如：Redis6、Mariadb10 等）的编译安装需要最低支持 c++11 的 gcc 5.x 版本。我们在需要升级 gcc 的版本。但是 Red Hat 为了软件的稳定和版本支持，yum 上版本也是 4.8.5，所以...","link":"","photos":[],"count_time":{"symbolsCount":"7.4k","symbolsTime":"7 mins."},"categories":[{"name":"CentOS","slug":"CentOS","count":5,"path":"api/categories/CentOS.json"}],"tags":[{"name":"CentOS","slug":"CentOS","count":5,"path":"api/tags/CentOS.json"},{"name":"gcc","slug":"gcc","count":1,"path":"api/tags/gcc.json"}],"author":{"name":"JaimeZeng","slug":"blog-author","avatar":"https://cdn.staticaly.com/gh/JaimeZeng/cdn/main/blog/avatar.png","link":"/","description":"Stay Simple.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":"https://github.com/JaimeZeng"}}}}}